from Tkinter import *import randomimport time# Define size of gui and each individual squarelength = 8max_square_size = 50half_max = max_square_size / 2last_coordinate = max_square_size * (length - 1) + half_max# Randomize which color is player and which is AIplayer_choices = [-1, 1]random_choice = random.randint(0, 1)AI = player_choices[random_choice]real_player = 1 if AI == -1 else -1player = real_playerdepthSearch = 3debug_mode = False# Toggles debug modedef toggle_debug_mode(event):    global debug_mode    debug_mode = not debug_mode    return debug_mode# Class for the GUI/Boardclass Board(Canvas):    # Create initial boardState matrix. 1 = white, -1 = black    boardState = [[0] * length, [0] * length, [0] * length,                  [0, 0, 0, 1, -1, 0, 0, 0],                  [0, 0, 0, -1, 1, 0, 0, 0],                  [0] * length, [0] * length, [0] * length]    def __init__(self, master):        Canvas.__init__(self, master, bg="white")        self.initialized = False        self.master = master        self.spaces = dict(zip([x for x in range(25, 376, 50)], [x for x in range(0, 9)]))        self.centerPixel = dict(zip([x for x in range(0, 9)], [x for x in range(25, 376, 50)]))        self.whitePiece = PhotoImage(file="white_circle.gif")        self.blackPiece = PhotoImage(file="black_circle.gif")        self.clk = None        self.ps = None        self.bind("<Button-1>", self.clickcords)        self.bind_all("<Return>", toggle_debug_mode)        self.pack(fill=BOTH, expand=1)    # Initializes who goes first.  If AI is black, minimax is ran    def initialize(self):        if not self.initialized:            timer = 3            print "Your color: %s" % ("black" if real_player == -1 else "white")            while timer != -1:                print "\rGame beginning in... " + str(timer),                time.sleep(1)                timer -= 1            if real_player == 1:                self.run_minimax()        self.initialized = True    # Draws the board    def draw_board(self, pos=None):        # Updates score displayed on top of window        score = getScore()        title = "Othello - SCORE: W=%d B=%d; " % (score[0], score[1])        title += "Player_Color: B;" if player == -1 else "Player_Color: W"        self.master.title(title)        # Draws all the squares in the window        num = 0        for i in range(length):            for n in range(length - i):                if i == 0:                    self.create_rectangle(max_square_size * n, max_square_size * n, max_square_size * (n + 1),                                          max_square_size * (n + 1),                                          outline="deepskyblue", fill="darkgreen")                else:                    if i % 2 == 1:                        color = "darkgreen"                    else:                        color = "darkgreen"                    x1 = max_square_size * (n + num)                    y1 = max_square_size * n                    x2 = max_square_size * (n + num + 1)                    y2 = max_square_size * (n + 1)                    self.create_rectangle(x1, y1, x2, y2,                                          outline="deepskyblue", fill=color,                                          tags="square")                    self.create_rectangle(y1, x1, y2, x2,                                          outline="deepskyblue", fill=color,                                          tags="square")                    # Highlights the squares when a square is clicked on                    if pos is not None:                        x, y = self.centerPixel[pos[1]], self.centerPixel[pos[0]]                        self.create_rectangle(x - half_max, y - half_max, x + half_max, y + half_max, outline="orange",                                              fill="lightblue")            num += 1        # Place images in gui/on board        self.setPieceImages()    # Updates by redrawing the board at a specified space    def UpdateBoard(self, position):        # First time the empty square is clicked, highlight it, else unhighlight it.        if self.clk == None or position != self.ps:            self.draw_board(position)            self.clk = 1            self.ps = position        else:            self.draw_board()            self.clk = None    # Uses pixel coordinates to determine which board space is clicked (row, column)    def getBoardPosition(self, coordinate):        least_distance = -1        position = 0        # Measures distance between each center pixel of each square to the pixel clicked        for PixelSpace in range(half_max, last_coordinate + 1, max_square_size):            # Get absolute value of distance            distance = ((PixelSpace - coordinate) ** 2) ** 0.5            if distance <= half_max:                position = self.spaces[PixelSpace]                break            # Checks corners of squares            if distance <= (half_max ** 2 + half_max ** 2) ** 0.5:                if least_distance == -1:                    position = self.spaces[PixelSpace]                    least_distance = distance                elif distance < least_distance:                    position = self.spaces[PixelSpace]                    least_distance = distance        return position    # Displays pieces on board    def setPieceImages(self):        for row in range(length):            for column in range(length):                img = self.whitePiece if Board.boardState[row][column] == 1 \                    else self.blackPiece if Board.boardState[row][column] == -1 \                    else 0                if img != 0:                    self.create_image(25 + (column * 50), 25 + (row * 50), image=img)    # Method ran every time something is clicked within the window.    def clickcords(self, event):        global player        # Rows start at the top, and columns start at the left with [row,column] label        # ei,   [0,0][0,1][0,2]        #       [1,0][1,1][1,2]        #       [2,0][2,1][2,2]        # Row position and column position are defined        rowPosition = self.getBoardPosition(event.y)        columnPosition = self.getBoardPosition(event.x)        position = [rowPosition, columnPosition]        # False if board matrix did not update        # Assigned to new board matrix if updated        successful_update = getBoardStateCopy(position)        # Update boardState matrix        if successful_update != False:            i = 0            for row in successful_update:                self.boardState[i] = row[:]                i += 1        # Use new matrix to update visual board        self.UpdateBoard(position)        score = getScore()        finalState = checkFinalState()        # Force GUI to refresh        self.master.update_idletasks()        # Display end game message if player fills last board space        if finalState:            title = "Game Finished! %s Won!" % ("White" if score[0] > score[1] else "Black")            title += "  W=" + str(score[0]) + " B=" + str(score[1])            self.master.title(title)        # Run minimax if matrix was updated and the AI can still move        elif successful_update != False and canPlayerMove(AI):            self.run_minimax()    # Initialize everything and runs minimax function    def run_minimax(self):        global player        if player == real_player:            # Returns state the algorithm chooses            # chosen_state = (state[][], [row,column])            chosen_state = miniMax(self.boardState)            i = 0            # Will only == -1 if there is no state to choose            if chosen_state != -1:                for row in chosen_state[0]:                    self.boardState[i] = row                    i += 1                self.UpdateBoard(chosen_state[1])                self.master.update_idletasks()            player = real_player            # If AI can move but player cannot, re-run minimax            if canPlayerMove(AI) and not canPlayerMove(real_player):                self.run_minimax()        # Check for win condition        score = getScore()        finalState = checkFinalState()        if finalState:            title = "Game Finished! %s Won!" % ("White" if score[0] > score[1] else "Black")            title += "  W=" + str(score[0]) + " B=" + str(score[1])            self.master.title(title)# Updates a board state matrix if necessary# Returns a copy of said state if copy is modifieddef getBoardStateCopy(position, directions=None, state=None):    orig_rowPosition = rowPosition = position[0]    orig_columnPosition = columnPosition = position[1]    boardStateCopy = []    if state is None:        state = Board.boardState    for row in state:        boardStateCopy.append(row[:])    # If what is clicked is an empty space    if boardStateCopy[rowPosition][columnPosition] == 0:        if directions is None:            # Directions of spaces where there are flippable pieces            valid_directions = checkFlank(position)        else:            valid_directions = directions        # If space clicked is a valid flank        if len(valid_directions) > 0:            # Flips all pieces in specified direction(s)            for direction in valid_directions:                rowPosition = orig_rowPosition                columnPosition = orig_columnPosition                rowDirection = "upward" if "upward" in direction else "downward" if "downward" in direction else None                columnDirection = "right" if "right" in direction else "left" if "left" in direction else None                rowIncrement = 1 if rowDirection == "downward" else -1 if rowDirection == "upward" else 0                columnIncrement = 1 if columnDirection == "right" else -1 if columnDirection == "left" else 0                # Updates boardState matrix for currently selected space                boardStateCopy[rowPosition][columnPosition] = player                rowPosition += rowIncrement                columnPosition += columnIncrement                # Flips all pieces in specified direction                # Updates boardState matrix after each flip                # player == -1 or 1, where -1 = black, and 1 = white                while boardStateCopy[rowPosition][columnPosition] != player:                    boardStateCopy[rowPosition][columnPosition] = player                    rowPosition += rowIncrement                    columnPosition += columnIncrement            # Switch player            return boardStateCopy    return False# Determines if specified position in a state is a valid flankdef checkFlank(position, board=None):    possible_directions = ["upward", "downward", "right", "left", "right_upward", "right_downward",                           "left_upward", "left_downward"]    valid_directions = []    orig_row = position[0]    orig_column = position[1]    # Tests all possible directions    for direction in possible_directions:        row = orig_row        column = orig_column        rowDirection = "upward" if "upward" in direction else "downward" if "downward" in direction else None        columnDirection = "right" if "right" in direction else "left" if "left" in direction else None        rowIncrement = 1 if rowDirection == "downward" else -1 if rowDirection == "upward" else 0        columnIncrement = 1 if columnDirection == "right" else -1 if columnDirection == "left" else 0        rowMax = 7 if rowDirection == "downward" else 0 if rowDirection == "upward" else -1        columnMax = 7 if columnDirection == "right" else 0 if columnDirection == "left" else -1        row += rowIncrement if (row != rowMax and rowMax != -1) else 0        column += columnIncrement if (column != columnMax and columnMax != -1) else 0        if row == orig_row:            rowIncrement = 0        if column == orig_column:            columnIncrement = 0        if board == None:            board = Board.boardState        while (row != rowMax and column != columnMax and board[row][column] != 0 and               board[row][column] != player):            row += rowIncrement            column += columnIncrement        changed = (row, column)        original = (orig_row, orig_column)        increments = (orig_row + rowIncrement, orig_column + columnIncrement)        validMove = (row, column) != increments if (rowIncrement, columnIncrement) != (0, 0) \            else row != increments[0] if rowIncrement != 0 else column        if board[row][column] == player and (changed != original and validMove):            if board[row - rowIncrement][column - columnIncrement] != player:                valid_directions.append(direction)    return valid_directions# Checks to see if a player can move in specified state# Returns true if there are any valid flanks the player can makedef canPlayerMove(playerTest, state=None):    global player    if state is None:        state = Board.boardState    orig_player = player    player = playerTest    for row in range(length):        for column in range(length):            if state[row][column] == 0:                flanks = checkFlank([row, column])                if len(flanks) > 0:                    player = orig_player                    return True    player = orig_player    return False# Checks to see if specified state is a winning/final state# Returns True if neither player can make any flanksdef checkFinalState(state=None):    global player    orig_player = player    if state is None:        state = Board.boardState    for row in range(length):        for column in range(length):            if state[row][column] == 0:                flanks = checkFlank([row, column])                if len(flanks) > 0:                    player = orig_player                    return False                player = opponent()                flanks = checkFlank([row, column])                if len(flanks) > 0:                    player = orig_player                    return False    return True# Returns current score of the gamedef getScore(state=None):    if state is None:        state = Board.boardState    white = 0    black = 0    for row in range(length):        for column in range(length):            if state[row][column] == 1:                white += 1            elif state[row][column] == -1:                black += 1    return white, black# Next few functions are used for MiniMax algorithm## Returns child states of specified statedef getChildren(state=None):    if state is None:        state = Board.boardState    children = []    for row in range(length):        for column in range(length):            if state[row][column] == 0:                flanks = checkFlank([row, column], state)                if len(flanks) > 0:                    child = getBoardStateCopy([row, column], flanks, state)                    children.append((child, (row, column)))    return children# Prints specified matrixdef printMatrix(state):    for row in state:        print row# Prints list of matricesdef printChildren(children):    for child in children:        printMatrix(child)# Returns heuristic value of specified statedef getHeuristicValue(child):    global player    # defaults each space value to 1    hValue = {(x, y): 1 for x in range(length) for y in range(length)}    score = getScore(child)    if player == 1:        playerScore = score[0]        opScore = score[1]    else:        playerScore = score[1]        opScore = score[0]    finshedGame = checkFinalState()    # Return max value if last state is in favor of player    # Else return min value    if finshedGame:        if playerScore > opScore:            return 100        else:            return -100    # Least valued spaces    hValue[(1, 1)] = -7    hValue[(1, 6)] = -7    hValue[(6, 1)] = -7    hValue[(6, 6)] = -7    # Lesser valued spaces    hValue[(0, 1)] = -5    hValue[(1, 0)] = -5    hValue[(0, 6)] = -5    hValue[(1, 7)] = -5    hValue[(6, 0)] = -5    hValue[(7, 1)] = -5    hValue[(6, 7)] = -5    hValue[(7, 6)] = -5    # Highest valued spaces    hValue[(0, 0)] = 7    hValue[(0, 7)] = 7    hValue[(7, 7)] = 7    hValue[(7, 0)] = 7    # Higher valued spaces    hValue[(0, 2)] = 5    hValue[(2, 0)] = 5    hValue[(7, 2)] = 5    hValue[(2, 7)] = 5    hValue[(5, 0)] = 5    hValue[(0, 5)] = 5    hValue[(7, 5)] = 5    # Nice valued spaces    hValue[(0, 3)] = 3    hValue[(0, 4)] = 3    hValue[(7, 3)] = 3    hValue[(7, 4)] = 3    hValue[(3, 0)] = 3    hValue[(4, 0)] = 3    hValue[(3, 7)] = 3    hValue[(4, 7)] = 3    player = opponent()    # Measures available moves for the opponent in current state    opAvailMoves = len(getChildren(child))    player = opponent()    # Measures how many pieces are beside an empty space    opponentPotentialMoves = 0    friendlyPotentialMoves = 0    # Measures total value of all of a player's pieces on board    opponentValue = 0    friendlyValue = 0    for row in range(length):        for column in range(length):            if child[row][column] == 0:                for i in range(2):                    if i == 0:                        friendlyPotentialMoves += getSurroundColor(child, (row, column), opponent())                    else:                        opponentPotentialMoves += getSurroundColor(child, (row, column), player)            elif child[row][column] == player:                friendlyValue += hValue[(row, column)]            else:                opponentValue += hValue[(row, column)]    # Opponent values are negatives    # Friendly are positive    total_hValue = float(friendlyValue) - float(opponentValue) - float(opAvailMoves) / 10.0 + float(        friendlyPotentialMoves) / 100.0 - \                   float(opponentPotentialMoves) / 100.0    return total_hValue# MiniMax algorithmdef miniMax(state, ply=depthSearch, level=1, alpha=-float('inf'), beta=float('inf'), max_level=None):    global player    global by_level_heuristics    # Switches player each recursion    player = opponent()    children = getChildren(state)    heuristics = []    heuristic_to_state = {}    if max_level is None:        max_level = ply        if debug_mode:            print "\n\nRoot Matrix:"            printMatrix(state)            print            print    if len(children) > 0:        # Iterates through children        for i in range(len(children)):            child = children[i]            # if on last level            if ply == 1:                heuristic = getHeuristicValue(child[0])                heuristics.append(heuristic)                heuristic_to_state[heuristic] = (child, heuristic)                # if maximizing layer                if level % 2 != 0:                    alpha = max(alpha, heuristic)                # Minimizing layer                else:                    beta = min(beta, heuristic)                if debug_mode:                    print "Level: " + str(level)                    printMatrix(child[0])                    print "Move (row, column): " + str(child[1])                    print "hValue: " + str(heuristic)                    print "Alpha: %.2f; Beta: %.2f" % (alpha, beta)                if beta <= alpha:                    if debug_mode:                        print "-------------------------------------------"                        print "BETA <= ALPHA; Rest of the children skipped"                        print "# of children remaining: " + str(len(children) - (i + 1))                        print "-------------------------------------------"                        print                    break                if debug_mode:                    print            else:                # Gets selected child from algorithm                # chosen_child = (child = (state, position), heuristic)                chosen_child = miniMax(child[0], ply - 1, level + 1, alpha, beta, max_level)                heuristics.append(chosen_child[1])                heuristic_to_state[chosen_child[1]] = (child, chosen_child[1])                # if maximizing layer                if level % 2 != 0:                    alpha = max(alpha, chosen_child[1])                # Minimizing layer                else:                    beta = min(beta, chosen_child[1])                if debug_mode:                    print "Level: " + str(level)                    printMatrix(child[0])                    print "Move (row, column): " + str(child[1])                    print "hValue: " + str(chosen_child[1])                    print "Alpha: %.2f, Beta: %.2f" % (alpha, beta)                if beta <= alpha:                    if debug_mode:                        print "-------------------------------------------"                        print "BETA <= ALPHA; Rest of the children skipped"                        print "# of children remaining: " + str(len(children) - (i + 1))                        print "-------------------------------------------"                        print                    break                if debug_mode:                    print            player = opponent()    # If state has no children,    # Get heuristic of current state and return    else:        heuristic = getHeuristicValue(state)        player = opponent()        return state, heuristic    # Sorts list of heuristics from least -> greatest    heuristics.sort()    # Maximizing level    if level % 2 != 0:        largest_heuristic = heuristics[len(heuristics) - 1]        chosen_child = heuristic_to_state[largest_heuristic]    # Minimizing level    else:        smallest_heuristic = heuristics[0]        chosen_child = heuristic_to_state[smallest_heuristic]    if level == 1:        player = real_player        if debug_mode:            print "FINAL MATRIX:"            printMatrix(chosen_child[0][0])            print "Chosen Move (Row, Column): " + str(chosen_child[0][1])            print "Heuristic: " + str(chosen_child[1])            print            print "-----------------------------"            print        # Returns just the child, not the heuristic        return chosen_child[0]    else:        # chosen_child = (child = (state, position), heuristic)        return chosen_child# Returns the number of specified color pieces are surrounding a spacedef getSurroundColor(state, position, colorNum):    num = 0    for row in range(position[0] - 1, position[0] + 2):        for column in range(position[1] - 1, position[1] + 2):            if 7 >= row >= 0 and 7 >= column >= 0:                if state[row][column] == colorNum:                    num += 1    return num# Flips playerdef opponent():    return 1 if player == -1 else -1